---
title: "seqbio.variant.scoring - pedigree-informed rare variant association and penetrance scoring"
author: "Cameron M. Nugent"
data: "`r Sys.Date()`"
output: pdf_document #rmarkdown::html_vignette # 
vignette: >
  %\VignetteIndexEntry{seqbio.variant.scoring-vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Introduction

When looking at shared rare variants across families, not all affected and unaffected individuals are equal. seqbio.variant.scoring is an R package meant to aid in comparative evaluation of candidate in family-based rare-variant association studies; the package considers evidence of rare variants' association with disease status in a family and score the variants based on relationships of individuals in a pedigree. Comparingscores across candidates can thereby help in assessing their relative merit.

The program leverages Wrightâ€™s coefficient of relatedness to score families based on the relationship of individuals as well as their disease status and genotypes for a given variant. A candidate variant is considered strongest when it is shared by an affected individual and other distantly-related affected family members and not shared by closely related unaffected family members. The theory behind this is that more distantly related individuals have a smaller proportion of their genome that is IBD, so the chance of a false positive (shared variant through chance, not due to association with disease) is lower. Conversely, when a closely related relative is unaffected, and the affected and unaffected individuals have different genotypes for the candidate variant, this provides evidence that the disease is not associated with the large IBD portion of the genome shared by the two individuals and thereby gives evidence in favour of the candidate.

```{r loadlib, echo = TRUE, results = 'hide', message=FALSE, warning=FALSE}
library(seqbio.variant.scoring)
```


## Input data

### The relation matrix

The function `read.relation.mat`
```{r}
mat.name1<-system.file('extdata/1234_ex2.mat', package = 'seqbio.variant.scoring')
rel.mat <- read.relation.mat(mat.name1)
rel.mat
``` 


### The status file

This file include the disease and variant status for all individuals


```{r}

tsv.name1<-system.file('extdata/1234_ex2.tsv', package = 'seqbio.variant.scoring')
status.df <- read.indiv(tsv.name1)

status.df
``` 

The disease-genotype scoring can then be encoded using the `score.variant.status` function.

```{r}

full.df.status <-  score.variant.status(status.df)
full.df.status 
``` 



## Scoring a family

For most real-world applications you will likely want to score an entire family in conjunction with one another and take the mean score. This can be accomplished with `score.fam`, which takes in the matrix of relationships and the table with encoded `statvar.cat` of all individuals.

```{r}

ex_score_default <- score.fam(rel.mat, full.df.status)
ex_score_default
``` 


By default `score.fam` returns:
- Nhe scores considering only the Affected individuals as the starting points (skipping the rows for MS-1234-1002, MS-1234-1006, and MS-1234-6001) in the previous example.
- The of the calculated score for each starting individuals.

Note that if an individual is present in the relationship matrix and not in the status file, it is assumed there is no genetic information for this individual and they are ignored when calculating the variant score.

The scoring can be changed to summing across all combinations as opposed to the mean by passing the following options. Note using the program in this way will return higher scores for more dense pedigrees.
```{r}

ex_score_sum <- score.fam(rel.mat, full.df.status, return.sums = TRUE, return.means = FALSE)
ex_score_sum
``` 


To obtain a long form table with the scores for variants expressed relative to each individual, set both `return.sums` and `return.means` to `FALSE`.
```{r}

ex_score_table <- score.fam(rel.mat, full.df.status, return.sums = FALSE, return.means = FALSE)
ex_score_table
``` 
## How scoring works 
### A Minimal example, scoring a variant from perspective of a single individual.

This section is meant to demonstrate how the variant scoring is accomplished on a finer scale. A user does not need to interact with the package on this level of granularity. This section is for explanatory purposes only.

Under the hood, the `score.fam` function is running the scoring method once for each affected individual in the status dataframe (or for each individual regardless of status if `affected.only = FALSE`). To do this, for each individual, the program takes corresponding row of the relationship matrix to determine the relations to all other individuals in the pedigree.  

For example, the degrees of relationships of all other members of the example family relative to the proband are show in the following subset of the matrix:

```{r}
rel.mat.proband <-  rel.mat["MS-1234-1001",]
rel.mat.proband
```
This is taken along with a list of encoded statuses of all individuals for the given variant. Obove `score.variant.status` used the disease status and a genetic variant are used to determine which category the combo falls in. Within `score.fam`, a labelled list of encodings for all individuals is generated. Where:
    - A_c = Affected individual with ALT variant
    - A_i = Affected individual without ALT variant
    - U_c = Unaffected individual without ALT variant
    - U_i = Unaffected individual with ALT variant
```{r}
name.stat.dict <- full.df.status$statvar.cat
names(name.stat.dict) <- full.df.status$name
name.stat.dict
```

`build.relation.dict` is used summarize the collate the status and relationship information and evidence affected and unaffected relations giving evidence for and evidence against a variant.
```{r}
rel.dict<-build.relation.dict(rel.mat.proband, name.stat.dict)
rel.dict
``` 
In this example, the proband, two first degree relations, and a third degree relations are all affected and share the candadte variant. For the affected correct (`A_c`) category we therefore see the following encoded:

```{r}
rel.dict$A_c
``` 

Since one first degree unaffected relative has the variant, they are categorized as "unaffected incorrect"(`U_i`) and we see:
```{r}
rel.dict$U_i
``` 

Scoring a relatedness-weighted score for the variant from the perspective of the given individual is then performed by `calc.rv.score`

For each encoded relationship, a relationship-informed weight is applied to their sharing or not sharing of a variant.

The score for affected status increase as individuals become more distantly related. The formula is:
```
   (1 / coefficient_of_relatedness) * affected.weight
```
For example, an affected cousin (encoded as a 3) would get a score of:
```
     (1/0.125) * affected.weight
     8 * 1
     = 8 points in favour of the variant.
```

for unaffected individuals, scores decay the further a person is in relation to the query individual based on the formula:
```
((unaffected.max*2) * coefficient_of_relatedness ) * unaffected.weight
```
For example, with the default `unaffected.weight = 0.5` and unaffected sister that does not have a variant would get a score of
```
     ((8*2) 0.5) * unaffected_weight
     (16 * 0.5) * 0.5
     = 4 points for the variant.

```

If these were the only two relatives considered we could sum the points and get a score in favour of the variant of
```
    8 + 4 = 12
```
If there is evidence against a variant, this is factored into the score as:
```
     total_score = evidence_for - evidence_against
```
For example, if there were also an affected sibling without the variant we would have the score against of:
```
  (1/0.5) * 1 = 2
```

The final score for the variant would then be:
```
     for - against = total
     12 - 2 = 10
```
Giving a final score of 10 for the variant.

This is all accomplished by the function `calc.rv.score`. 
```{r}
calc.rv.score(rel.dict)
``` 

The weights of the scoring can be adjusted, for example if we wanted to consider only `affected`-based evidence, we could turn off the unaffected part of the calculation by setting the unaffected weighting to 0. This can be useful for incompletely penetrant variants, where disease status and genotype of unaffected indiviudals are more likely to have imperfect concordance.

```{r}
calc.rv.score(rel.dict, unaffected.weight=0)
``` 

The `score.fam` function automatically walks through this process from all specified perspectives in the pedigree and by default returns the average score. The use of the averages and different perspectives is meant to eliminate pedigree-associated bias, such as for instances when a proband is distantly related to all other members in a family (considering the relationships from only the perspective of the proband in this case would give an inflated score for the variant's value).


```{r}


``` 


```{r}


``` 
